vide (liberté) --> coord1, coord2..
allié (((this.id%2)+1) --> coord1, coord2..
ennemi --> coord1, coord2..
indéfini/!\



poser le pion (grid[x][y] = this.id;)
ennGrpAr = tableau

ennemi ==>
si ennGrpAr.lastIndexOf(ennemi[i].group) == -1 (grp pas encore modifié) ennGrpAr.push(ennemi[i].group) + enlever les libertés au group ennemi[i].group
si libertés du group ennemi[i].group == 0 on remplace les cases du groupe par 0 et on vide le tableau de ennemi[i] group, + on rajoute des libertés dans les grp autour
sinon si libertés == 1 vérifier si cette liberté a des libertés, si c'est le cas ne rien faire
		  sinon push liberté du group sélectionné dans tab[id]
			si la longueur du tableau est de 2, vérifier si dans tab toutes les libertés sont à 1
				si c'est le cas ne rien faire
				sinon on met unplay[id qui a 1 seule liberté partout]
			si elle est de 1, vérifier si dans tab[id] toutes les libertés sont à 1
				si c'est le cas, mettre unplay[id]

allié ==>
si grid[x][y] == this.id, grid[x][y] = {id:this.id,group:allié.group} + push {x:x, y:y} grp[allié.group];
sinon fusionner grp (rajouter toutes les coordonnées de grid[x][y].group dans grp[allié.group])

vide ==>
liberté suicide ? vérifier si cette liberté a des libertés, si c'est le cas ne rien faire
		  sinon push liberté du group sélectionné dans tab[id]
			si la longueur du tableau est de 2, vérifier si dans tab toutes les libertés sont à 1
				si c'est le cas ne rien faire
				sinon on met unplay[id qui a 1 seule liberté partout]
			si elle est de 1, vérifier si dans tab[id] toutes les libertés sont à 1
				si c'est le cas, mettre unplay[id]

				--------------------

libertés ? reparcourir toutes les cases de group[grid[x][y].group] et compter leur liberté en modifiant la case par 0.5
remettre les cases à 0
liberté suicide ? si liberté == 1 vérifier si cette liberté a des libertés, si c'est le cas ne rien faire
		  sinon push liberté du group sélectionné dans tab[id]
			si la longueur du tableau est de 2, vérifier si dans tab toutes les libertés sont à 1
				si c'est le cas ne rien faire
				sinon on met unplay[id qui a 1 seule liberté partout]
			si elle est de 1, vérifier si dans tab[id] toutes les libertés sont à 1
				si c'est le cas, mettre unplay[id]


les deux plusieurs fois = on fait rien
un une fois l'autre deux fois = on fait rien
les deux une fois = on fait rien
un une fois l'autre 0 fois = on vérifie si il y a un autre groupe autour avec le même id (qui a donc plus de 1 liberté) et si oui on fait rien, sinon on met unplay + id
les deux aucune fois = on vérifie si y a une seule id autour, si oui on met l'autre id en unplay

fin de partie:

this.endGrid = this.grid;

on analyse les cases une par une, si c'est un 0 on lance la fonction récursive suivante :
	met la case à 0
	il rajoute +0.5
	il regarde toutes les cases autour de lui et place around dans tab[0] fait tab[id]++
	var newtab = fonction récursive (tab[0] à tab[tab.length])
	tab[0].concat(newtab[0]);
	tab[1] += newtab[1];
	tab[2] += newtab[2];
	return tab;

si tab[1] > 0 && tab[2] > 0 
	var tabSize = this.libGrp[0].length;
	this.libGrp[0][tabSize] = [];
	this.libGrp[0][tabSize] = this.libGrp[0][tabSize].concat(tab[0]);
sinon si tab[1] > 0
	var tabSize = this.libGrp[1].length;
	this.libGrp[1][tabSize] = [];
	this.libGrp[1][tabSize] = this.libGrp[1][tabSize].concat(tab[1]);
sinon si tab[2] > 0
	var tabSize = this.libGrp[2].length;
	this.libGrp[2][tabSize] = [];
	this.libGrp[2][tabSize] = this.libGrp[2][tabSize].concat(tab[2]);


for (var i = 0; i < this.libGrp[1].length; i++)
	this.libGrp[1][i]
	this.check(x et y du tab) (qui met toutes les libertés et les pions du paramètre (id) dans un tab)
	rajoute 10 à l'id ou à la case
}

pareil pour this.libGrp[2]